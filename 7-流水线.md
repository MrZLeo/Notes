# 流水线

## 1. 背景

1. 需要更快的性能：超算、模拟、量子系统、深度学习、云计算、3A游戏……
2. 需要从时间和空间上更好地利用CPU（CPU大部分时间都处于空闲状态）

## 2. 流水线技术（Pipeline）的定义

> # 将一重复的处理过程分解成若干字过程，每个子过程都可以有效地在其专用功能段上与其他子过程同时执行。

## 3. 特点

1. 大量可分解的重复劳动

2. 交错式复用处理部件

3. 需要冷启动时间，冷启动后才能稳定
4. 子过程称为流水线的“级”或 ==“段”（stage）==，段的数目称为流水线的==“深度”==
5. 每个子过程的时间段应该基本相同，通常为一个时钟周期（1拍）

## 4. 分类

### 4.1. 功能：单功能、多功能

- 单功能：只能完成一种固定功能的流水线
- 多功能：各段可以进行不同的连接，从而实现不同的功能
  - ![image-20210914092725170](https://raw.githubusercontent.com/MrZLeo/Image/main/uPic/2021/09/14/image-20210914092725170.png)

### 4.2. 同一时间内流水段的连接方式：静态、动态

- 静态流水线：指**同一时间内**，流水线的各段只能按同一种功能的连接方式工作
- 动态流水线：在**同一时间内**，当某些段正在实现某种运算的时候，另一段却在实现另一种运算
- 特点：前者适合处理一串相同的运算操作，后者更灵活但会使流水线的控制变得很复杂

### 4.3 级别：处理器级、部件级、宏级（处理机间）

- 处理器级：取指、译码、取操作数、执行、访存、写回
- 部件级：一个单一部件内进行（e.g. 浮点加法分为求阶差、对阶、尾数相加、规格化四步）
- ![image-20210914094328408](https://raw.githubusercontent.com/MrZLeo/Image/main/uPic/2021/09/14/image-20210914094328408.png)
- 系统级流水线（宏级）：在多个计算机系统中由多个处理机串行构成的流水线
- ![image-20210914094340833](https://raw.githubusercontent.com/MrZLeo/Image/main/uPic/2021/09/14/image-20210914094340833.png)

### 4.4 反馈回路：线性、非线性

- 线性：无反馈回路
- 非线性：有反馈回路（i.e. 存在直通技术）
- ![image-20210914094454077](https://raw.githubusercontent.com/MrZLeo/Image/main/uPic/2021/09/14/image-20210914094454077.png)

### 4.5 输入与输出顺序：顺序、乱序

- 顺序：`input == output`
- 乱序：`input != output`

### 4.6 标量与向量流水线

- 标量：只能对标量数据进行计算
- 向量：单指令多数据：GPU、TPU、AVX指令集……

## 5. 性能分析

### 5.1 吞吐率

> # 吞吐率是指单位时间内流⽔线所完成的任务数或输出结果的数量。

#### 5.1.1 最大吞吐率

> # 最⼤吞吐率$TP_{max}$是指流⽔线在达到稳定状态后所得到的吞吐率。
>
> 假设流水线各段的时间相等，均为 $\Delta t_{0}$ ，则：
> $$
> T P_{\max }=1 / \triangle t_{0}
> $$
> 假设流水线各段时间不等，第 $\mathrm{i}$ 段时间为 $\Delta t_{i}$, 则:
> $$
> T P_{\max }=1 / \max \left\{\Delta t_{i}\right\}
> $$
>
> - 最大吞吐率取决于流水线中最慢⼀段所需的时间， 该段成为**流水线的瓶颈**
> - 消除瓶颈的方法
>   - 细分瓶颈段
>   - 重复设置瓶颈段
>
> <img src="/Users/mrzleo/Library/Application Support/typora-user-images/image-20220104145542700.png" alt="image-20220104145542700" style="zoom:50%;" />

#### 5.1.2 实际吞吐率

> # 设流⽔线由**m**段组成，完成**n**个任务的吞吐率称为实际吞吐率，记作**TP**。
>
> $$
> \text {若各段时间相等 (假设均为} \Delta t_{0}) \text {，则完成时间 } \\
> T_{\text {流水}}=m \Delta t_{0}+(n-1) \Delta t_{0} \\
> \begin{aligned}
> \text {实际吞吐率} \quad T P &=\frac{n}{T_{\text {流水 }}}=\frac{n}{m \cdot \Delta t_{0}+(n-1) \Delta t_{0}} \\
> &=\frac{1}{\Delta t_{o}\left(1+\frac{m-1}{n}\right)}=\frac{T P_{\max }}{1+\frac{m-1}{n}} \\
> \mathrm{TP} &<\mathrm{TP}_{\max } \\
> & \text { 当 } n \gg m \text { 时, } T P \approx \mathrm{TP}_{\max }
> \end{aligned} \\
> \text {若各段时间不不等(假设第i段为} \Delta ti\text {)，则完成时间} \\
> T=\sum_{i=1}^{m} \Delta t_{i}+(\mathrm{n}-1) \Delta t_{j} \\
> \text { 这里, } \Delta t_{j}=\max \left\{\Delta t_{i}\right\} \\
> \text {实际吞吐率} \quad T P=\frac{n}{\sum_{i=1}^{m} \Delta t_{i}+(n-1) \Delta t_{j}}
> $$

### 5.2 加速比

> # 加速比是指流水线速度与等功能的非流水线速度之比。
>
> $$
> \text { 加速比 } S=T_{\text {非流水 }} / T_{\text {流水 }} \\
> \text { 若流水线为 } m \text { 段, 每段时间均为 } \Delta t_{0} \\
> \begin{gathered}
> T_{\text {非流水 }}=n m \Delta t_{0,} \quad T_{\text {流水 }}=m \Delta t_{0}+(n-1) \Delta t_{0} \\
> S=\frac{m n}{m+n-1}=\frac{m}{1+\frac{m-1}{n}}
> \end{gathered} \\
> \text { 可以看出: 当 } n \gg m \text { 时, } S \approx m
> $$
>
> 如果每段流水线的时间不同，则求完成全部任务所需的时间和流水线情况下完成全部任务的时间之比，即**时空图的横坐标之比**

### 5.3 效率

> # 从时**-**空图上看，效率就是**n**个任务所占的时空区与 **m**个段总的时空区之比
>
> $$
> E=\frac{n \text { 个任务占用的时空区 }}{m \text { 个段总的时空区 }}
> $$

## 6 流水线中的相关

> # 流水线中的相关是指相邻或相近的两条指令因存在某种关联，后⼀条指令不能在原先指定的时钟周期开始执行。

### 6.1 相关的分类

1. **结构相关**

   **硬件资源**满足不了指令重叠执行的要求

2. **数据相关**

   一条指令需要⽤到**前面指令的结果**

3. **控制相关**

​	流水线遇到**分⽀指令**和其它会改变**PC**值的指令

> # 转移指令引起的控制相关，对流⽔计算机吞吐率、效率的影响⽐比数据相关严重的多，所以被称为全局性相关。

> # 数据相关⼀一般被称为局部性相关

### 6.2 结构相关

> # 在流水线机器中，为了使各种指令组合能顺利地重叠执行，需要把功能部件流水化，并把资源重复设置。

可能造成结构相关的原因：

1. 功能部件不是全流水的
2. 重复设置的资源数量不足

> # 实例：当数据和指令存在同一存储器中时，访存指令会引起存储器访问冲突 
>
> <img src="/Users/mrzleo/Library/Application Support/typora-user-images/image-20220104162400873.png" alt="image-20220104162400873" style="zoom: 50%;" />
>
> - 解决方法：
>   1. 插入暂停周期
>   2. 设置相互独立的指令存储器和数据存储器或设置相互独立的指令Cache和数据Cache
>
> <img src="/Users/mrzleo/Library/Application Support/typora-user-images/image-20220104162523450.png" alt="image-20220104162523450" style="zoom:50%;" />

避免结构相关的方法：

1. 所有功能单元流水化
2. 设置足够多的硬件资源

### 6.3 数据相关

#### 6.3.1 分类

<u>两条指令 i 和 j</u>，都会访问同一寄存器**R**，假设 **i** 先进入流水线，则它们对**R**有四种不同的访问顺序：

1. 写后读 RAW

   如果**j** 在**i** 完成写之前从**R** 中读出数据，将得到错误的结果

2. 写后写 WAW

   最终应该保存j写的结果，但如果j在i之前完成写入，最后会保存i得结果，该结果是错误的

3. 读后写 WAR

   如果j先写入了错误的值，那么i读到的的值是错误的

4. 读后读 RAR

   该操作不会产生错误

#### 6.3.2 解决方案

1. 直通技术

   直通技术能够在结果计算出来之后**直接将其送入后续指令**计算的元器件中，而不需要等到数据写入内存空间之后才能被后续指令使用。

2. 增加专用硬件（实现暂停等待）

3. 利用编译器调度，尝试重新排列指令以排除数据相关

### 6.4 控制相关

1. 无条件跳转

2. 条件跳转

   条件跳转由于不知道是否跳转，必须等待跳转条件计算得到之后才能确定，而此时已经有很多后续指令进行了部分运行，跳转会导致已经加载的指令全部作废，流水线停滞。

#### 6.4.1 解决方案

1. 冻结流水线（freeze）

2. 预取分⽀目标

3. 多流（**multiple streams**）

   在条件分支的两路路上同时启动取指令操作，并将指令保存到分支指令被实际执行时。

4. 循环缓冲器（**loop buffer**）

   循环缓冲器是⼀个小的、⾮常高速的存储器，保存着最近获取的**n**条顺序的指令。如果分支发生，硬件首先检查分支目标是否在 缓冲器中。如果在，下一条指令从缓冲中获取。

5. 分支预测（赌的成分🥸）

   1. 静态预测：总是猜跳转、不跳转、由编译器预测（包括程序中的某些编译指令,如c++中的`#[[likely]]`）、测试法（先模拟运行得到概率相关的数据再交由编译器编译）
   2. 动态预测：通过记录分支指令的近期运行历史，并以此作为预测的依据，来提高分支预测的准确度。
      - 分支历史表**branch history table**：
        - 使用状态机的机制来实现预测
        - ![image-20220104172303420](https://raw.githubusercontent.com/MrZLeo/Image/main/uPic/2022/01/04/image-20220104172303420.png)
        - ![image-20220104172228847](https://raw.githubusercontent.com/MrZLeo/Image/main/uPic/2022/01/04/image-20220104172228847.png)

6. 延迟分支(**delayed branch**)：在跳转命令后插入一条指令进行执行，如果没有符合条件的指令，则插入空指令

<img src="https://raw.githubusercontent.com/MrZLeo/Image/main/uPic/2022/01/04/image-20220104172856043.png" alt="image-20220104172856043" style="zoom:50%;" />

## 7. 流水线效率的进一步提高

### 7.1 增加流水线的长度

- 局限性：
  1. 指令执⾏过程的细化是有限度的
  2. 随着流⽔线深度的增加，流水线段之间的缓冲器增多，**延迟加大**，使流水线的性能提高受到阻碍

> # 超流水线（**Super Pipeline**）
>
> 将流水线的**IF**、**ID**、**ALU**等关键步骤进⼀步细分为多 个**stages**，故称为**super-pipeline**

### 7.2 并行增加流水线的数量

> # 超标量流水线（**Superscalar**）
>
> 内置多个流水线一起跑，借助硬件资源重复来实现空间的并行，实现**IPC > 1**

> # 超标量超流水（**Superpipelined Superscalar**）
>
> 多流水线 **+** 指令级细分

<img src="/Users/mrzleo/Library/Application Support/typora-user-images/image-20220104173524142.png" alt="image-20220104173524142" style="zoom:50%;" />

## 8. 多流水技术

### 8.1 静态多发射 

> # VLIW： 编译器打包多个可并行的指令
>
> 缺点：
>
> 1. 对编译器要求过⾼
> 2. 数据相关的代价过⼤大

### 8.2 动态多发射

> # 按序发射，按序执⾏：如果当前的指令需要用到某个值还没有计算出来的寄存器，那么这条指令就不能发出。
>
> 使用下面的规则来判断该指令是否能发射：
>
> 1. 如果任何一个源操作数寄存器正在被写，就不能发射 （RAW）
> 2. 如果保存结果的寄存器正在被读，就不能发射 （WAR）
> 3. 如果保存结果的寄存器正在被写，也不能发射  （WAW）

按序发射的效率不高，因此考虑**乱序发射**：

#### 8.2.1 硬件方案之一：计分牌

<img src="/Users/mrzleo/Library/Application Support/typora-user-images/image-20220105114316971.png" alt="image-20220105114316971" style="zoom:50%;" />

记分牌控制的**四阶段**：

1. **Issue—**指令译码，检测结构相关

​	如果当前指令所使用的功能部件空闲，并且没有其他活动的指令使用相同的目的寄存器(WAW), 记分牌发射该指令到功能部件，并更新记分牌内部数据；如果有结构相关或WAW相关，则该指令的发射暂停，并且也不发射后继指令，直到相关解除。

2. **Read operands—**没有数据相关时，读操作数

​	如果先前已发射的正在运行的指令不对当前指令的源操作数寄存器进行写操作，或者⼀个正在⼯作的功能部件已经完成了对该寄存器的写操作，则该操作数有效。操作数有效时，记分牌控制功能部件读操作数，准备执行。

> # 记分牌在这一步动态地解决了RAW相关，指令可能会乱序执行。

3. **Execution—**取到操作数后执行 **(EX)**

​	接收到操作数后，功能部件开始执行。当计算出结果后，它通知记分牌，可以结束该条指令的执行.

4. **Write result—finish execution (WB)**

​	⼀旦记分牌得到功能部件执⾏完毕的信息后，记分牌检测WAR相关，如果没有WAR相关，就写结果，如果有WAR相关，则暂停该条指令。

计分牌的结构：

1. Instruction status—记录正在执行的各条指令所处的状态步

2. Functional unit status—记录功能部件(FU)的状态。⽤9个域记录每个功能部件的9个参量:

   `Busy`—指示该部件是否空闲 

   `Op`—该部件所完成的操作 

   `Fi`—其⽬目的寄存器器编号	

   `Fj, Fk`—源寄存器器编号

   `Qj, Qk`—产⽣生源操作数`Fj, Fk`的功能部件

   `Rj, Rk`—标识源操作数`Fj, Fk`是否就绪的标志

3. Register result status

   如果存在功能部件对某⼀寄存器进⾏写操作，指示具体是哪个功能部件对该寄存器进⾏写操作。如果没有指令对该寄存器进⾏写操作，则该域为Blank.

<img src="/Users/mrzleo/Library/Application Support/typora-user-images/image-20220105153605775.png" alt="image-20220105153605775" style="zoom:67%;" />

> 更多高级内容以后填坑……
