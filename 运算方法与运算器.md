# 运算方法与运算器

> 定点数；浮点数；ALU

## 定点数运算

### 加减运算

#### 补码加减运算规则：

-  参加运算的操作数用补码表示
- 补码的符号位与数值位同时进行加运算
  - ➕：两数补码直接相加
  - ➖：**减数**补码连同符号位一起按位取反，末位加**1**；再与被减数的补码**相加**。
  -  运算结果即为**和/差**的补码

#### 溢出判断

> ⚠️当两个**同符号的数相加**（或者是**相异符号数相减**）时，运算结果可能发生溢出

- 双符号位判决法
- 进位判决法
- 符位与进位标志判别法：
  - OverFlow Flag(OF)
  - Carrier Flag(CF)
  - Sign Flag(SF)
  - $OF = CF \oplus SF$

### 乘法

#### 原码

##### 一位乘

1. 符号位：乘数与被乘数符号异或
2. 乘积的绝对值：被乘数的绝对值与乘数的绝对值之积
3. 原码的计算方法：分别算出符号位和绝对值，然后拼接在一起

- 计算机的方式：位移
- **e.g.** $B \times A = 1101 \times 1011$

```c

   CF     D       A
	0    0000    1011
+        1101
----------------------
    0    1101    1011
// A 右移一位， A最右与B按位异或
...
// 最终得到完整的积
```

##### 两位乘

- 四种组合 $Y_{i+1}Y_i = 00, 01, 10, 11$

- 最值得注意的是$Y_{i+1}Y_i = 10$时，因为此时值为3，直接加显得非常麻烦。最好的解决方案是先减去当前一位的$X$，然后右移后再加上，相当于$3|X| = 4|X| - |X|$。
  - 此时需要一个特别的值来记录是否欠着一个$X$.

#### 补码

##### 一位乘

1. 矫正法
   - 完全不需要考虑符号，直接一起运算
   - 矫正：if 乘数是一个负数，$+[-X]_补$
2. **Booth method**

- 日常的计算技巧：
  - $12345 × 1001 = 12345 × (1000 + 1)$
  - $2342 × 999 = 2342 × (1000 − 1)$
- 对于二进制也一样适用：
  - $1010 × 0111 = 1010 × (1000 − 1)$
  - $1010 × 1110 = 1010 × (10000 − 10)$
  - 对于二进制来说，适用面更广，只需要找到**一串1**即可

> **Booth**算法:
>
> - 从右向左，遇到**“1 0”**就是**“一串1”**的开始，在**1**的位置减$|X|$; 
> - 从右向左，遇到**“0 1”**就是**“一串1”**的结束，在**0**的位置加$|X|$;
>
> - 中间的**“00”**和**“11”**都不管!
> - <img src="/Users/mrzleo/Library/Application Support/typora-user-images/image-20210613150551592.png" alt="image-20210613150551592" style="zoom:50%;" />

### 除法

>  前提条件：
>
>  1. 除数 $\neq 0$
>
>  2. 商是可以表示的

#### 原码

- 前提条件：
  1. 定点纯小数时，$｜被除数｜ < |除数|$
  2. 定点纯整数时，$｜被除数｜ > |除数|$
- 商的符号 = 被除数的符号 $\oplus$ 除数的符号
- 法则：
  - 被除数（余数）每次减去右移一次后的除数，决定上商
  - 实际：保持除数不变，余数左移

##### 恢复余数法：

- 减去除数之后判断够不够减，若不够，将除数加回来**（恢复余数）**
- 过程不规范，难以控制

##### 加减交替法

- 若$R \ge 0$，**商1**，余数左移，减除数
- 若$R \lt 0$，**商0**，余数左移，加除数

#### 补码

- 先决条件：
  - 定点纯小数
  - 除数 $ \neq 0 $
- 法则**（除数与余数）**
  - 同号 ➖ 除数
  - 异号 ➕ 除数
  - 余数同号商1，否则商0
  - 末尾为1保证精度

> ⚠️**全部方法要手算几次，以保证熟练**

## 浮点数

### 加减运算

#### 法则：

- **对阶**：统一阶码。

>  小阶对大阶

- **尾数加减运算**
- **规格化**

1. 左规：阶码-1，检查下溢 —>  **00.0xxxx**或**11.1xxxx**类

2. 右规：阶码+1，检查上溢 —> **01.xxxxx**或**10.xxxxx**类

- **舍入处理**

1. 截断
2. 末尾恒置1
3. 0舍1入

### 乘除运算

#### 乘法

1. 阶码 = 两阶码之和
2. 尾数 = 两位数之积

#### 除法

1. 阶码 = 被除数阶码 - 除数阶码
2. 尾数 = 被除数尾数 / 除数尾数

> ｜被除数｜ < ｜除数｜
>
> 补码除法，除尽时商1

## 几点经验

1. booth法计算时需要考虑两位符号位，**两位原码需要考虑三位符号位**
2. 一位原码计算时不需要考虑符号位，最左边的一位留出来是为了防止溢出
3. 特别小心到了符号位处的计算
4. 分清楚什么类型的运算，原码运算就需要将全部数字看作绝对值，$-|X|$ 就是对绝对值求补码；补码运算则需要将全部数字都看作补码，$Y$ 包含一位符号位，$-X$ 就是直接对补码整个求负值（反转+1）

5. $[-X]_{补} = [X]_{补}直接求补（包括符号位）$
6. 原码除法（加减交替）先商零，再位移，再进行加减。计算商的时候，第一位0舍去。
7. 补码除法先判断符号，再加减，再判断符号（此时商0/1）

